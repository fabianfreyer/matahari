# vim: set ft=python :

import os
from util import *
from config import toolchain, components, debugger

env = Environment(
	PATH = '%(base)s/%(tuple)s/bin/' % toolchain,
	CC = tool('gcc'),
	LD = tool('ld'),
	OBJCOPY = '%(base)s/%(tuple)s/bin/%(tuple)s-objcopy' % toolchain,
	OBJDUMP = '%(base)s/%(tuple)s/bin/%(tuple)s-objdump' % toolchain,
	LDFLAGS = '-melf_i386 -static -nostdlib -nmagic',
	CFLAGS = '-g -Os -m32 -march=i686 -ffreestanding -fno-pic -ffast-math -fomit-frame-pointer -Wall -Werror -Iinclude -DARCH_i386',
	PROGSUFFIX='',
	)
env.AddMethod(Link)

# statically build the objects
objects = env.StaticObject(
		Component('mbr', components['mbr']['modules'])
		+Component('stage2', components['stage2']['modules'])
		)

# build an elf of the loader
env.Link('loader.elf', objects, 'loader.ld')
env.AddPostAction('loader.elf', CheckSectionHeaders)

# separate the mbr and stage2 sections into separate binary files
env.Command('mbr.bin', 'loader.elf', '$OBJCOPY -O binary %(sections)s $SOURCES $TARGET' % {
	'sections': '-j '+(' -j '.join(components['mbr']['sections']))
	})
env.Command('stage2.bin', 'loader.elf', '$OBJCOPY -O binary %(sections)s $SOURCES $TARGET' % {
	'sections': '-j '+(' -j '.join(components['stage2']['sections']))
	})

# concatenate the files to generate a disk image
env.Command('image.bin', ['mbr.bin', 'stage2.bin'], 'cat $SOURCES > $TARGET')
if debugger and ARGUMENTS.get('debug', 0):
	env.AlwaysBuild('image.bin') # make sure the post action is called
	env.AddPostAction('image.bin', debugger)
